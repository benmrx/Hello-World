{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf830
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red113\green157\blue207;\red0\green41\blue57;\red238\green238\blue236;
\red78\green201\blue176;\red138\green226\blue50;\red120\green151\blue105;\red229\green218\blue115;}
{\*\expandedcolortbl;;\csgenericrgb\c44314\c61569\c81176;\csgenericrgb\c0\c16078\c22353;\csgenericrgb\c93333\c93333\c92549;
\csgenericrgb\c30588\c78824\c69020;\csgenericrgb\c54118\c88627\c19608;\csgenericrgb\c47059\c59216\c41176;\csgenericrgb\c89804\c85490\c45098;}
\margl1440\margr1440\vieww17260\viewh14860\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs24 \cf2 \cb3 using\cf4  System.Collections;\uc0\u8232 \cf2 using\cf4  System.Collections.Generic;\uc0\u8232 \cf2 using\cf4  UnityEngine;\uc0\u8232 \u8232 \cf2 public\cf4  \cf2 class\cf4  \cf5 EllenEnemyRaycast\cf4  : MonoBehaviour \{\uc0\u8232 \u8232 \u8232 \u8232     \cf2 public\cf4  \cf2 float\cf4  rayDistance = \cf6 10f\cf4 ;\uc0\u8232     \cf2 public\cf4  \cf2 float\cf4  rayHeight = \cf6 1\cf4 ;\uc0\u8232     \cf2 public\cf4  \cf2 float\cf4  nextActionTime = \cf6 1f\cf4 ;\uc0\u8232     \cf2 public\cf4  \cf2 float\cf4  period = \cf6 1f\cf4 ;\uc0\u8232 \u8232     \cf2 public\cf4  \cf2 bool\cf4  hitLeft;\uc0\u8232     \cf2 public\cf4  \cf2 bool\cf4  hitRight;\uc0\u8232 \u8232 \u8232     \cf7 // Use this for initialization\uc0\u8232 \cf4     \cf2 void\cf4  Start () \uc0\u8232     \{\u8232 \u8232     \}\u8232     \u8232     \cf7 // Update is called once per frame\uc0\u8232 \cf4     \cf2 void\cf4  Update () \uc0\u8232     \{\u8232         \cf2 if\cf4 (Time.time > nextActionTime)\uc0\u8232         \{\u8232             nextActionTime += period;\u8232             EnemyRaycastLeft();\u8232             EnemyRaycastRight();\u8232         \}\u8232     \}\u8232 \u8232     \cf2 public\cf4  \cf2 void\cf4  EnemyRaycastLeft()\uc0\u8232     \{\u8232         Debug.DrawRay(transform.position + \cf2 new\cf4  Vector3(\cf6 0f\cf4 , rayHeight), Vector2.left * rayDistance, Color.blue);\uc0\u8232         RaycastHit2D hit;\u8232 \u8232         hit = Physics2D.Raycast(transform.position + \cf2 new\cf4  Vector3(\cf6 0f\cf4 , rayHeight), Vector2.left, rayDistance, \cf6 1\cf4  << \cf6 9\cf4 );\uc0\u8232         \cf2 if\cf4  (hit.collider)\uc0\u8232         \{\u8232             hitLeft = \cf2 true\cf4 ;\uc0\u8232             \cf2 if\cf4  (hitLeft == \cf2 true\cf4 )\uc0\u8232             \{\u8232                 print(\cf8 "Enemy on the LEFT"\cf4 );\uc0\u8232             \}\u8232             \cf2 else\uc0\u8232 \cf4             \{\uc0\u8232                 hitLeft = \cf2 false\cf4 ;\uc0\u8232             \}\u8232         \}\u8232     \}\u8232 \u8232     \cf2 public\cf4  \cf2 void\cf4  EnemyRaycastRight()\uc0\u8232     \{\u8232         Debug.DrawRay(transform.position + \cf2 new\cf4  Vector3(\cf6 0f\cf4 , rayHeight), Vector2.right * rayDistance, Color.red);\uc0\u8232         RaycastHit2D hit;\u8232 \u8232         hit = Physics2D.Raycast(transform.position + \cf2 new\cf4  Vector3(\cf6 0f\cf4 , rayHeight), Vector2.right, rayDistance, \cf6 1\cf4  << \cf6 9\cf4 );\uc0\u8232         \cf2 if\cf4  (hit.collider)\uc0\u8232         \{\u8232             hitRight = \cf2 true\cf4 ;\uc0\u8232             \cf2 if\cf4 (hitRight == \cf2 true\cf4 )\uc0\u8232             \{\u8232                 print(\cf8 "Enemy on the RIGHT"\cf4 );\uc0\u8232             \}\u8232             \cf2 else\uc0\u8232 \cf4             \{\uc0\u8232                 hitRight = \cf2 false\cf4 ;\uc0\u8232             \}\u8232         \}\u8232     \}\u8232 \}\u8232 \u8232 }